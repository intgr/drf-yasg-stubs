from collections import OrderedDict
from typing import Any, Optional, Union, List, Dict, Tuple, Type, ClassVar, Callable, KeysView, Iterable, Iterator

from rest_framework.serializers import Serializer
from typing_extensions import Literal

TYPE_OBJECT: Literal["object"] = "object"
TYPE_STRING: Literal["string"] = "string"
TYPE_NUMBER: Literal["number"] = "number"
TYPE_INTEGER: Literal["integer"] = "integer"
TYPE_BOOLEAN: Literal["boolean"] = "boolean"
TYPE_ARRAY: Literal["array"] = "array"
TYPE_FILE: Literal["file"] = "file"
_TYPE_any = Literal["object", "string", "number", "integer", "boolean", "array", "file"]

FORMAT_DATE: Literal["date"]
FORMAT_DATETIME: Literal["date-time"]
FORMAT_PASSWORD: Literal["password"]
FORMAT_BINARY: Literal["binary"]
FORMAT_BASE64: Literal["bytes"]
FORMAT_FLOAT: Literal["float"]
FORMAT_DOUBLE: Literal["double"]
FORMAT_INT32: Literal["int32"]
FORMAT_INT64: Literal["int64"]

FORMAT_EMAIL: Literal["email"]
FORMAT_IPV4: Literal["ipv4"]
FORMAT_IPV6: Literal["ipv6"]
FORMAT_URI: Literal["uri"]

FORMAT_UUID: Literal["uuid"]
FORMAT_SLUG: Literal["slug"]
FORMAT_DECIMAL: Literal["decimal"]
_FORMAT_any = Literal[
    "date",
    "date-time",
    "password",
    "binary",
    "bytes",
    "float",
    "double",
    "int32",
    "int64",
    "email",
    "ipv4",
    "ipv6",
    "uri",
    "uuid",
    "slug",
    "decimal",
]

IN_BODY: Literal["body"]
IN_PATH: Literal["path"]
IN_QUERY: Literal["query"]
IN_FORM: Literal["formData"]
IN_HEADER: Literal["header"]
_IN_any = Literal["body", "path", "query", "formData", "header"]

SCHEMA_DEFINITIONS: Literal["definitions"]

# Enum can only can only be applied to primitives and they must have uniform types
_EnumType = Union[List[str], List[int], List[bool], List[float]]

def make_swagger_name(attribute_name: str): ...

class SwaggerDict(OrderedDict):
    _extras__: Dict[str, Any] = ...
    def __init__(self, **attrs: Any): ...
    def __setattr__(self, key: str, value: Any) -> None: ...
    def __getattr__(self, item: str): ...
    def __delattr__(self, item: str) -> None: ...
    def _insert_extras__(self) -> None: ...
    def as_odict(self): ...
    def __reduce__(self): ...

class Contact(SwaggerDict):
    name: Optional[str] = ...
    url: Optional[str] = ...
    email: Optional[str] = ...
    def __init__(
        self, name: Optional[str] = ..., url: Optional[str] = ..., email: Optional[str] = ..., **extra: Any
    ): ...

class License(SwaggerDict):
    name: str = ...
    url: Optional[str] = ...
    def __init__(self, name: str, url: Optional[str] = ..., **extra: Any): ...

class Info(SwaggerDict):
    title: str = ...
    _default_version: str = ...
    description: Optional[str] = ...
    terms_of_service: Optional[str] = ...
    contact: Optional[Contact] = ...
    license: Optional[License] = ...
    def __init__(
        self,
        title: str,
        default_version: str,
        description: Optional[str] = ...,
        terms_of_service: Optional[str] = ...,
        contact: Optional[Contact] = ...,
        license: Optional[License] = ...,
        **extra: Any
    ): ...

class Swagger(SwaggerDict):
    swagger: str = ...
    info: Optional[Info] = ...
    base_path: Optional[str] = ...
    consumes: Optional[List[str]] = ...
    produces: Optional[List[str]] = ...
    security_definitions: Optional[Dict[str, dict]] = ...
    security: Optional[Dict[str, List[str]]] = ...
    paths: Optional[Paths] = ...
    definitions: Optional[Dict[str, Schema]] = ...

    host: str = ...
    schemes: List[str] = ...
    def __init__(
        self,
        info: Optional[Info] = ...,
        _url: Optional[str] = ...,
        _prefix: Optional[str] = ...,
        _version: Optional[str] = ...,
        consumes: Optional[List[str]] = ...,
        produces: Optional[List[str]] = ...,
        security_definitions: Optional[Dict[str, dict]] = ...,
        security: Optional[Dict[str, List[str]]] = ...,
        paths: Optional[Paths] = ...,
        definitions: Optional[Dict[str, Schema]] = ...,
        **extra: Any
    ): ...
    @classmethod
    def get_base_path(cls, script_prefix: str, api_prefix: str) -> str: ...

class Paths(SwaggerDict):
    def __init__(self, paths: Dict[str, PathItem], **extra: Any): ...

class PathItem(SwaggerDict):
    OPERATION_NAMES: ClassVar[List[str]] = ...

    get: Optional[Operation] = ...
    head: Optional[Operation] = ...
    post: Optional[Operation] = ...
    put: Optional[Operation] = ...
    patch: Optional[Operation] = ...
    delete: Optional[Operation] = ...
    options: Optional[Operation] = ...
    parameters: Optional[List[Parameter]] = ...
    def __init__(
        self,
        get: Optional[Operation] = ...,
        put: Optional[Operation] = ...,
        post: Optional[Operation] = ...,
        delete: Optional[Operation] = ...,
        options: Optional[Operation] = ...,
        head: Optional[Operation] = ...,
        patch: Optional[Operation] = ...,
        parameters: Optional[List[Parameter]] = ...,
        **extra: Any
    ): ...
    @property
    def operations(self) -> List[Tuple[str, Operation]]: ...

class Operation(SwaggerDict):
    operation_id: str = ...
    responses: Responses = ...
    parameters: Optional[List[Parameter]] = ...
    consumes: Optional[List[str]] = ...
    produces: Optional[List[str]] = ...
    summary: Optional[str] = ...
    description: Optional[str] = ...
    tags: Optional[List[str]] = ...
    security: Optional[Dict[str, List[str]]] = ...
    def __init__(
        self,
        operation_id: str,
        responses: Responses,
        parameters: Optional[List[Parameter]] = ...,
        consumes: Optional[List[str]] = ...,
        produces: Optional[List[str]] = ...,
        summary: Optional[str] = ...,
        description: Optional[str] = ...,
        tags: Optional[List[str]] = ...,
        security: Optional[Dict[str, List[str]]] = ...,
        **extra: Any
    ): ...

class Items(SwaggerDict):
    type: _TYPE_any = ...
    format: Optional[_FORMAT_any] = ...
    enum: Optional[_EnumType] = ...
    pattern: Optional[str] = ...
    items_: Optional[Items] = ...
    def __init__(
        self,
        type: _TYPE_any = ...,  # Type is required
        format: Optional[_FORMAT_any] = ...,
        enum: Optional[_EnumType] = ...,
        pattern: Optional[str] = ...,
        items: Optional[Items] = ...,
        **extra: Any
    ): ...

class Parameter(SwaggerDict):
    name: str = ...
    in_: _IN_any = ...
    description: Optional[str] = ...
    required: Optional[bool] = ...
    schema: Optional[_SchemaOrRef] = ...
    type: Optional[_TYPE_any] = ...
    format: Optional[_FORMAT_any] = ...
    enum: Optional[_EnumType] = ...
    pattern: Optional[str] = ...
    items_: Optional[Items] = ...
    default: Optional[Any] = ...
    def __init__(
        self,
        name: str,
        in_: _IN_any,
        description: Optional[str] = ...,
        required: Optional[bool] = ...,
        schema: Optional[_SchemaOrRef] = ...,
        type: Optional[_TYPE_any] = ...,
        format: Optional[_FORMAT_any] = ...,
        enum: Optional[_EnumType] = ...,
        pattern: Optional[str] = ...,
        items: Optional[Items] = ...,
        default: Optional[Any] = ...,
        **extra: Any
    ): ...

class Schema(SwaggerDict):
    OR_REF: Tuple[Type[SwaggerDict], ...] = ...

    title: Optional[str] = ...
    description: Optional[str] = ...
    type: Optional[_TYPE_any] = ...
    format: Optional[_FORMAT_any] = ...
    enum: Optional[_EnumType] = ...
    pattern: Optional[str] = ...
    properties: Optional[Any] = ...
    additional_properties: Optional[Any] = ...
    required: Optional[Any] = ...
    items_: Optional[Any] = ...
    default: Optional[Any] = ...
    read_only: Optional[bool] = ...
    def __init__(
        self,
        title: Optional[str] = ...,
        description: Optional[str] = ...,
        type: Optional[_TYPE_any] = ...,
        format: Optional[_FORMAT_any] = ...,
        enum: Optional[_EnumType] = ...,
        pattern: Optional[str] = ...,
        properties: Optional[Any] = ...,
        additional_properties: Optional[Any] = ...,
        required: Optional[List[str]] = ...,
        items: Optional[Any] = ...,
        default: Optional[Any] = ...,
        read_only: Optional[bool] = ...,
        **extra: Any
    ): ...

class _Ref(SwaggerDict):
    ref_name_re: Any = ...
    ref: Any = ...
    def __init__(self, resolver: Any, name: Any, scope: Any, expected_type: Any, ignore_unresolved: bool = ...): ...
    def resolve(self, resolver: Any): ...
    def __setitem__(self, key: Any, value: Any): ...
    def __delitem__(self, key: Any) -> None: ...

class SchemaRef(_Ref):
    def __init__(self, resolver: Any, schema_name: Any, ignore_unresolved: bool = ...): ...

_SerializerOrClass = Union[Serializer, Type[Serializer]]
_SchemaOrRef = Union[Schema, SchemaRef]

def resolve_ref(ref_or_obj: Any, resolver: Any): ...

class Responses(SwaggerDict):
    default: Optional[Response] = ...
    def __init__(self, responses: Dict[Union[str, int], Response], default: Optional[Response] = ..., **extra: Any): ...

class Response(SwaggerDict):
    description: str = ...
    schema: Optional[Union[_SchemaOrRef, _SerializerOrClass]] = ...
    examples: Optional[Dict[str, Any]] = ...
    def __init__(
        self,
        description: str,
        schema: Optional[Union[_SchemaOrRef, _SerializerOrClass]] = ...,
        examples: Optional[Dict[str, Any]] = ...,
        **extra: Any
    ): ...

# TODO this can be made a Generic[T]?
# TODO: Mapping[str, T]?
class ReferenceResolver(Iterable[Any]):
    def __init__(self, *scopes: str, force_init: bool = ..., **kwargs: Any): ...
    def with_scope(self, scope: str) -> ReferenceResolver: ...
    def set(self, name: str, obj: Any, scope: Optional[str] = ...) -> None: ...
    def setdefault(self, name: str, maker: Callable[[], Any], scope: Optional[str] = ...): ...
    def get(self, name: str, scope: Optional[str] = ...) -> Any: ...
    def getdefault(self, name: str, default: Optional[Any] = ..., scope: Optional[str] = ...): ...
    def has(self, name: str, scope: Optional[str] = ...) -> bool: ...
    def __iter__(self) -> Iterator[Any]: ...
    @property
    def scopes(self) -> List[str]: ...
    def keys(self) -> KeysView: ...
    def __getitem__(self, item: str): ...
